template <class T>
class BinaryTree {
private:
    T element;
    BinaryTree* parent_node;
    BinaryTree* left;
    BinaryTree* right;

public:
    BinaryTree(T obj, BinaryTree* p = nullptr)
    {
        element = obj;
        parent_node = p;
        left = nullptr;
        right = nullptr;
    }

    T retrieve() const {
        return element;
    }

    BinaryTree* parent() {
        return parent_node;
    }

    BinaryTree* left_child() {
        return left;
    }

    BinaryTree* right_child() {
        return right;
    }

    bool is_root() {
        return parent_node == nullptr;
    }

    bool is_leaf() {
        return (left_child() == nullptr && right_child() == nullptr);
    }

    int size() 
    {
        return 1 + (left() == nullptr) ? 0 : left()->size() 
                 + (right() == nullptr) ? 0 : right()->size();
    }

    int height()
    {
        if (is_leaf())
        {
            return 0;
        }
        else
        {
       
            return 1 + std::max((left() == nullptr) ? 0 : left()->size() + (right() == nullptr) ? 0 : right()->size());
        }
    }

    void clear()
    {
        if (left_child() != nullptr)
        {
            left_child()->clear(left)
        }
        if (right_child() != nullptr)
        {
            right_child()->clear(right)
        }
        delete this;
    }   
};
